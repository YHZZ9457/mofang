<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>多阶 3D 魔方 - 终极版</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #050505;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            user-select: none;
            -webkit-user-select: none;
            color: #fff;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            cursor: grab;
            display: block;
        }
        #canvas-container:active {
            cursor: grabbing;
        }

        /* 底部按钮栏 */
        #ui-container {
            position: absolute;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 15px;
            pointer-events: none;
            z-index: 20;
            align-items: center;
        }

        button, select {
            pointer-events: auto;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: rgba(255, 255, 255, 0.9);
            padding: 10px 24px;
            font-size: 14px;
            font-weight: 600;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.2s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
            outline: none;
        }

        select {
            appearance: none;
            text-align: center;
            padding-right: 30px;
            background-image: url("data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%23FFFFFF%22%20d%3D%22M287%2069.4a17.6%2017.6%200%200%200-13-5.4H18.4c-5%200-9.3%201.8-12.9%205.4A17.6%2017.6%200%200%200%200%2082.2c0%205%201.8%209.3%205.4%2012.9l128%20127.9c3.6%203.6%207.8%205.4%2012.8%205.4s9.2-1.8%2012.8-5.4L287%2095c3.5-3.5%205.4-7.8%205.4-12.8%200-5-1.9-9.2-5.5-12.8z%22%2F%3E%3C%2Fsvg%3E");
            background-repeat: no-repeat;
            background-position: right 12px top 50%;
            background-size: 10px auto;
        }
        select option {
            background: #333;
            color: #fff;
        }

        button:hover, select:hover {
            background: rgba(255, 255, 255, 0.25);
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(0,0,0,0.3);
            color: #fff;
        }

        /* 左上角说明 */
        #instructions {
            position: absolute;
            top: 30px;
            left: 30px;
            color: rgba(255, 255, 255, 0.5);
            font-size: 13px;
            pointer-events: none;
            background: rgba(0,0,0,0.3);
            padding: 15px 20px;
            border-radius: 12px;
            line-height: 1.8;
            border: 1px solid rgba(255,255,255,0.05);
            z-index: 20;
        }
        .highlight { color: #fff; font-weight: 700; }

        /* 右上角设置面板 */
        #settings-panel {
            position: absolute;
            top: 30px;
            right: 30px;
            width: 200px;
            background: rgba(0,0,0,0.4);
            backdrop-filter: blur(12px);
            padding: 20px;
            border-radius: 16px;
            border: 1px solid rgba(255,255,255,0.1);
            z-index: 30;
        }

        .setting-item { margin-bottom: 15px; }
        .setting-item:last-child { margin-bottom: 0; }
        
        .setting-label {
            font-size: 12px;
            color: rgba(255,255,255,0.8);
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
        }

        input[type=range] {
            -webkit-appearance: none;
            width: 100%;
            background: transparent;
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 14px;
            width: 14px;
            border-radius: 50%;
            background: #fff;
            cursor: pointer;
            margin-top: -5px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            cursor: pointer;
            background: rgba(255,255,255,0.2);
            border-radius: 2px;
        }
    </style>
</head>
<body>

    <div id="instructions">
        <div><span class="highlight">左键</span> 拖拽方块 = 旋转魔方层</div>
        <div><span class="highlight">右键</span> 拖拽背景 = 自由旋转视角</div>
        <div><span class="highlight">滚轮</span> 缩放视角</div>
    </div>

    <!-- 设置面板 -->
    <div id="settings-panel">
        <div class="setting-item">
            <div class="setting-label">
                <span>魔方灵敏度</span>
                <span id="val-cube">0.85</span>
            </div>
            <input type="range" id="input-cube-sens" min="0.2" max="2.0" step="0.05" value="0.85">
        </div>
        <div class="setting-item">
            <div class="setting-label">
                <span>视角灵敏度</span>
                <span id="val-view">1.0</span>
            </div>
            <input type="range" id="input-view-sens" min="0.2" max="3.0" step="0.1" value="1.0">
        </div>
    </div>

    <div id="ui-container">
        <!-- 阶数选择 -->
        <select id="select-order">
            <option value="2">2阶 (2x2)</option>
            <option value="3" selected>3阶 (3x3)</option>
            <option value="4">4阶 (4x4)</option>
            <option value="5">5阶 (5x5)</option>
        </select>
        <button id="btn-scramble">随机打乱</button>
        <button id="btn-reset">重置</button>
    </div>

    <div id="canvas-container"></div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { ArcballControls } from 'three/addons/controls/ArcballControls.js';
        import { RoundedBoxGeometry } from 'three/addons/geometries/RoundedBoxGeometry.js';

        // --- 参数配置 ---
        const CUBE_SIZE = 1;
        const SPACING = 0.02; // 稍微增加间隙以适应高阶
        const TOTAL_SIZE = CUBE_SIZE + SPACING;
        
        // 动态状态
        let currentOrder = 3; // 当前阶数
        let cubeSensitivity = 0.85;
        let viewSensitivity = 1.0;
        
        const SNAP_SPEED = 0.3; 
        const DRAG_DEADZONE = 5;

        // 配色方案
        const COLORS = {
            R: 0xb90000, L: 0xff5525, U: 0xffd500, 
            D: 0xffffff, F: 0x0045ad, B: 0x009e60, 
            I: 0x151515 // 内部颜色加深
        };

        let scene, camera, renderer, controls;
        let cubes = [];
        let pivot;
        let particleSystem;
        
        let isDragging = false;
        let isSnapping = false;
        
        const state = {
            startMouse: new THREE.Vector2(),
            lastMouse: new THREE.Vector2(),
            intersectCube: null,
            intersectNormal: null,
            rotateAxis: null,
            currentGroupAngle: 0,
            activeCubes: []
        };

        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        init();
        animate();

        function init() {
            const container = document.getElementById('canvas-container');

            // 1. 场景设置
            scene = new THREE.Scene();
            // 更加深邃的背景 fog
            scene.fog = new THREE.FogExp2(0x050505, 0.02);

            // 2. 相机
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
            camera.position.set(8, 6, 10);
            
            // 3. 渲染器
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setClearColor(0x050505);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            container.appendChild(renderer.domElement);

            // 4. 灯光系统
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);
            
            const mainLight = new THREE.DirectionalLight(0xffffff, 1.5);
            mainLight.position.set(10, 20, 10);
            mainLight.castShadow = true;
            mainLight.shadow.mapSize.width = 2048;
            mainLight.shadow.mapSize.height = 2048;
            scene.add(mainLight);

            const backLight = new THREE.DirectionalLight(0x4455ff, 0.5); // 蓝色背光
            backLight.position.set(-10, 5, -10);
            scene.add(backLight);

            // 5. Pivot 旋转轴心
            pivot = new THREE.Object3D();
            scene.add(pivot);

            // 6. 场景装饰 (背景优化)
            createEnvironment();

            // 7. 控制器
            controls = new ArcballControls(camera, renderer.domElement, scene);
            controls.enableAnimations = true;
            controls.dampingFactor = 10;
            controls.wMax = 20;
            controls.setGizmosVisible(false);
            controls.rotateSpeed = viewSensitivity;
            controls.unsetMouseAction(0);
            controls.setMouseAction('ROTATE', 2); 
            controls.setMouseAction('ZOOM', 1);

            // 8. 初始化魔方
            createRubiksCube(currentOrder);

            // 9. 事件监听
            setupEvents();
        }

        function createEnvironment() {
            // 星空粒子
            const particleGeo = new THREE.BufferGeometry();
            const particleCount = 1500;
            const posArray = new Float32Array(particleCount * 3);
            for(let i=0; i<particleCount*3; i++) {
                posArray[i] = (Math.random() - 0.5) * 60; // 分散在 60x60x60 空间
            }
            particleGeo.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
            const particleMat = new THREE.PointsMaterial({
                size: 0.05,
                color: 0xaaaaaa,
                transparent: true,
                opacity: 0.8,
                sizeAttenuation: true
            });
            particleSystem = new THREE.Points(particleGeo, particleMat);
            scene.add(particleSystem);

            // 科技感网格地面
            const gridHelper = new THREE.GridHelper(50, 50, 0x333333, 0x111111);
            gridHelper.position.y = -10;
            scene.add(gridHelper);
        }

        function setupEvents() {
            const canvas = renderer.domElement;
            
            window.addEventListener('resize', onWindowResize);
            canvas.addEventListener('mousedown', onMouseDown);
            window.addEventListener('mousemove', onMouseMove);
            window.addEventListener('mouseup', onMouseUp);
            canvas.addEventListener('contextmenu', e => e.preventDefault());

            // UI 绑定
            document.getElementById('btn-scramble').addEventListener('click', scrambleCube);
            document.getElementById('btn-reset').addEventListener('click', () => createRubiksCube(currentOrder));
            
            // 阶数选择
            const selectOrder = document.getElementById('select-order');
            selectOrder.addEventListener('change', (e) => {
                currentOrder = parseInt(e.target.value);
                createRubiksCube(currentOrder);
                // 调整相机距离以适应大魔方
                const dist = 6 + currentOrder * 1.5;
                camera.position.setLength(dist);
            });

            // 灵敏度设置
            document.getElementById('input-cube-sens').addEventListener('input', (e) => {
                cubeSensitivity = parseFloat(e.target.value);
                document.getElementById('val-cube').textContent = cubeSensitivity.toFixed(2);
            });
            document.getElementById('input-view-sens').addEventListener('input', (e) => {
                viewSensitivity = parseFloat(e.target.value);
                controls.rotateSpeed = viewSensitivity;
                document.getElementById('val-view').textContent = viewSensitivity.toFixed(1);
            });
        }

        function createRubiksCube(order) {
            // 清理旧魔方
            cubes.forEach(c => scene.remove(c));
            cubes = [];
            pivot.rotation.set(0,0,0);
            pivot.children = []; // 清空 Pivot 子对象

            // 稍微减小圆角以适应密集结构
            const bevelSize = order > 3 ? 0.05 : 0.08;
            const geometry = new RoundedBoxGeometry(CUBE_SIZE, CUBE_SIZE, CUBE_SIZE, 4, bevelSize);

            const offset = (order - 1) / 2;

            for (let x = 0; x < order; x++) {
                for (let y = 0; y < order; y++) {
                    for (let z = 0; z < order; z++) {
                        
                        // 仅在表面的方块上色
                        const isRight = x === order - 1;
                        const isLeft  = x === 0;
                        const isTop   = y === order - 1;
                        const isBottom= y === 0;
                        const isFront = z === order - 1;
                        const isBack  = z === 0;

                        const materials = [
                            getMat(isRight ? COLORS.R : COLORS.I),
                            getMat(isLeft ? COLORS.L : COLORS.I),
                            getMat(isTop ? COLORS.U : COLORS.I),
                            getMat(isBottom ? COLORS.D : COLORS.I),
                            getMat(isFront ? COLORS.F : COLORS.I),
                            getMat(isBack ? COLORS.B : COLORS.I),
                        ];

                        const mesh = new THREE.Mesh(geometry, materials);
                        
                        // 计算位置：使其居中
                        mesh.position.set(
                            (x - offset) * TOTAL_SIZE,
                            (y - offset) * TOTAL_SIZE,
                            (z - offset) * TOTAL_SIZE
                        );

                        mesh.castShadow = true;
                        mesh.receiveShadow = true;
                        mesh.userData = { isCube: true }; // 标记
                        
                        scene.add(mesh);
                        cubes.push(mesh);
                    }
                }
            }
        }

        function getMat(color) {
            return new THREE.MeshPhysicalMaterial({
                color: color,
                roughness: 0.5,
                metalness: 0.1,
                clearcoat: 0.5,
                clearcoatRoughness: 0.1
            });
        }

        // --- 交互逻辑 ---

        function onMouseDown(event) {
            if (isSnapping || event.button !== 0) return;

            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(cubes);

            if (intersects.length > 0) {
                controls.enabled = false;
                isDragging = true;
                
                state.intersectCube = intersects[0].object;
                state.intersectNormal = intersects[0].face.normal.clone()
                    .transformDirection(state.intersectCube.matrixWorld)
                    .round();

                state.startMouse.set(event.clientX, event.clientY);
                state.lastMouse.set(event.clientX, event.clientY);
                state.rotateAxis = null; 
                state.currentGroupAngle = 0;
            }
        }

        function onMouseMove(event) {
            if (!isDragging || isSnapping) return;

            const dx = event.clientX - state.lastMouse.x;
            const dy = event.clientY - state.lastMouse.y;
            
            // 1. 尚未确定轴向时，检测拖拽方向
            if (!state.rotateAxis) {
                const dist = new THREE.Vector2(event.clientX, event.clientY).distanceTo(state.startMouse);
                if (dist < DRAG_DEADZONE) return;

                determineAxisByProjection(new THREE.Vector2(event.clientX - state.startMouse.x, event.clientY - state.startMouse.y));
                
                if (state.rotateAxis) {
                    preparePivotGroup();
                }
            }

            // 2. 已确定轴向，执行实时旋转
            if (state.rotateAxis) {
                const screenMove = new THREE.Vector2(dx, dy);
                const projectedTangent = getProjectedTangent(state.rotateAxis);
                // 投影点积决定旋转方向和量级
                const moveAmount = screenMove.dot(projectedTangent);
                
                state.currentGroupAngle += moveAmount * cubeSensitivity * 0.01;
                
                pivot.rotation[state.rotateAxis] = state.currentGroupAngle;
                pivot.updateMatrixWorld();
            }

            state.lastMouse.set(event.clientX, event.clientY);
        }

        function determineAxisByProjection(screenMoveVec) {
            const normal = state.intersectNormal;
            const axes = ['x', 'y', 'z'];
            const worldAxes = { x: new THREE.Vector3(1,0,0), y: new THREE.Vector3(0,1,0), z: new THREE.Vector3(0,0,1) };
            
            let maxDot = -1;
            let bestAxis = null;

            axes.forEach(axis => {
                const axisVec = worldAxes[axis];
                // 如果该轴与法线平行，则不能绕该轴旋转当前面
                if (Math.abs(axisVec.dot(normal)) > 0.9) return;

                // 3D 空间中的切线方向
                const tangent3D = new THREE.Vector3().crossVectors(axisVec, normal).normalize();
                // 投影到屏幕空间
                const screenTangent = projectVectorToScreen(tangent3D, state.intersectCube.position);
                // 计算鼠标移动向量与屏幕切线的相似度
                const dot = Math.abs(screenMoveVec.clone().normalize().dot(screenTangent));

                if (dot > maxDot) {
                    maxDot = dot;
                    bestAxis = axis;
                }
            });

            if (bestAxis && maxDot > 0.4) state.rotateAxis = bestAxis;
        }

        function getProjectedTangent(rotationAxis) {
            const normal = state.intersectNormal;
            const worldAxes = { x: new THREE.Vector3(1,0,0), y: new THREE.Vector3(0,1,0), z: new THREE.Vector3(0,0,1) };
            const tangent3D = new THREE.Vector3().crossVectors(worldAxes[rotationAxis], normal).normalize();
            return projectVectorToScreen(tangent3D, state.intersectCube.position);
        }

        function projectVectorToScreen(vector, origin) {
            const p1 = origin.clone();
            const p2 = origin.clone().add(vector);
            p1.project(camera);
            p2.project(camera);
            return new THREE.Vector2((p2.x - p1.x) * window.innerWidth / 2, -(p2.y - p1.y) * window.innerHeight / 2).normalize();
        }

        // 准备旋转层：根据被点击方块的位置，选出同一层的所有方块
        function preparePivotGroup() {
            const axis = state.rotateAxis;
            const targetPos = state.intersectCube.position[axis];
            
            state.activeCubes = [];
            cubes.forEach(cube => {
                // 使用小容差 float 比较，判断是否在同一层
                if (Math.abs(cube.position[axis] - targetPos) < 0.1) {
                    state.activeCubes.push(cube);
                }
            });

            // 重置 Pivot
            pivot.rotation.set(0, 0, 0);
            pivot.position.set(0, 0, 0);
            // 将选中方块挂载到 Pivot
            state.activeCubes.forEach(cube => pivot.attach(cube));
        }

        function onMouseUp() {
            if (!isDragging) return;
            isDragging = false;
            controls.enabled = true;

            if (state.rotateAxis) {
                snapRotation();
            }
        }

        // --- 改进的归位逻辑 (支持 > 90度) ---
        function snapRotation() {
            isSnapping = true;
            
            const step = Math.PI / 2; // 90度
            // 计算当前旋转了多少个 90度
            const k = Math.round(state.currentGroupAngle / step);
            const targetAngle = k * step;

            const axis = state.rotateAxis;
            
            function animateSnap() {
                const diff = targetAngle - pivot.rotation[axis];
                // 动态速度，距离越远越快，最慢速度有保底
                const speed = Math.max(Math.abs(diff) * 0.15, 0.02); 

                if (Math.abs(diff) < 0.005) {
                    pivot.rotation[axis] = targetAngle;
                    pivot.updateMatrixWorld();
                    finishRotation();
                    return;
                }
                
                // 简单的阻尼逼近
                pivot.rotation[axis] += diff * 0.25; 
                requestAnimationFrame(animateSnap);
            }
            animateSnap();
        }

        function finishRotation() {
            state.activeCubes.forEach(cube => {
                scene.attach(cube);
                // 修正位置误差，确保严丝合缝
                cube.position.x = Math.round(cube.position.x / TOTAL_SIZE) * TOTAL_SIZE;
                cube.position.y = Math.round(cube.position.y / TOTAL_SIZE) * TOTAL_SIZE;
                cube.position.z = Math.round(cube.position.z / TOTAL_SIZE) * TOTAL_SIZE;
                
                // 修正旋转矩阵误差
                const e = cube.matrixWorld.elements;
                // 将矩阵元素修整为 -1, 0, 1
                [0,1,2,4,5,6,8,9,10].forEach(i => e[i] = Math.round(e[i]));
                
                cube.matrixWorld.decompose(cube.position, cube.quaternion, cube.scale);
                cube.updateMatrixWorld();
            });
            
            isSnapping = false;
            state.rotateAxis = null;
            state.activeCubes = [];
            state.currentGroupAngle = 0;
        }

        function scrambleCube() {
            if (isSnapping || isDragging) return;
            
            const axes = ['x', 'y', 'z'];
            const step = Math.PI / 2;
            
            // 快速打乱动画
            let moveCount = 0;
            const totalMoves = 20 + currentOrder * 2; // 阶数越高打乱越多

            function nextMove() {
                if(moveCount >= totalMoves) return;

                // 随机选一个轴
                const axis = axes[Math.floor(Math.random() * 3)];
                // 随机选一个方块作为层的基准 (这样自然适配任意阶数)
                const randomCube = cubes[Math.floor(Math.random() * cubes.length)];
                const layerPos = randomCube.position[axis];

                // 随机方向 (1 或 -1)
                const dir = Math.random() > 0.5 ? 1 : -1;
                // 随机圈数 (对于打乱，通常90度或180度)
                const turns = Math.random() > 0.8 ? 2 : 1; 

                // 选出该层所有方块
                const activeCubes = cubes.filter(c => Math.abs(c.position[axis] - layerPos) < 0.1);

                pivot.rotation.set(0,0,0);
                activeCubes.forEach(c => pivot.attach(c));
                
                // 瞬间完成旋转计算
                pivot.rotation[axis] = dir * turns * step;
                pivot.updateMatrixWorld();
                
                activeCubes.forEach(c => {
                    scene.attach(c);
                    c.position.x = Math.round(c.position.x / TOTAL_SIZE) * TOTAL_SIZE;
                    c.position.y = Math.round(c.position.y / TOTAL_SIZE) * TOTAL_SIZE;
                    c.position.z = Math.round(c.position.z / TOTAL_SIZE) * TOTAL_SIZE;
                    const e = c.matrixWorld.elements;
                    [0,1,2,4,5,6,8,9,10].forEach(k => e[k] = Math.round(e[k]));
                    c.matrixWorld.decompose(c.position, c.quaternion, c.scale);
                    c.updateMatrixWorld();
                });

                moveCount++;
                // 使用 setTimeout 稍微间隔一下，防止卡顿，产生视觉效果
                setTimeout(nextMove, 10); 
            }
            
            nextMove();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            
            // 简单的粒子动画
            if(particleSystem) {
                particleSystem.rotation.y += 0.0005;
            }
            
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>